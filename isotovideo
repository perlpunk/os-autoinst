#!/usr/bin/perl -w
# Copyright © 2009-2013 Bernhard M. Wiedemann
# Copyright © 2012-2020 SUSE LLC
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, see <http://www.gnu.org/licenses/>.
#

=head1 SYNOPSIS

isotovideo [OPTIONS] [TEST PARAMETER]

Parses command line parameters, vars.json and tests the given assets/ISOs.

=head1 OPTIONS

=over 4

=item B<-d, --debug>

Enable direct output to STDERR instead of autoinst-log.txt

=item B<-v, --version>

Show the current program version and test API version

=item B<-h, -?, --help>

Show this help.

=head1 TEST PARAMETER

All additional command line arguments specified in the C<key=value> format are
parsed as test parameters which take precedence over the settings in the
vars.json file. Lower case key names are transformed into upper case
automatically for convenience.

=cut

use strict;
use warnings;
use autodie ':all';
no autodie 'kill';

my $installprefix;    # $bmwqemu::scriptdir
my $fatal_error;      # the last error message catched by the die handler

BEGIN {
    # the following line is modified during make install
    $installprefix = undef;

    # record the last die message
    # note: It might *not* be a fatal error so we don't call bmwqemu::serialize_state here
    #       immediately but only in the END block.
    $SIG{__DIE__} = sub { $fatal_error = shift };

    my ($wd) = $0 =~ m-(.*)/-;
    $wd            ||= '.';
    $installprefix ||= $wd;
    unshift @INC, "$installprefix";
}

use bmwqemu;
use needle;
use autotest;
use commands;
use distribution;
use testapi 'diag';
use File::Basename qw(dirname);
use Getopt::Long;
use IPC::System::Simple;
use POSIX qw(:sys_wait_h _exit);
use IO::Select;
Getopt::Long::Configure("no_ignore_case");
use OpenQA::Isotovideo::Interface;
use OpenQA::Isotovideo::Utils qw(checkout_git_repo_and_branch
  checkout_git_refspec handle_generated_assets load_test_schedule);

use OpenQA::Isotovideo qw( $backend_process $cmd_srv_process $testprocess
  $command_handler $testfd $cmd_srv_port );

OpenQA::Isotovideo::startup();

my %options;
# global exit status
my $return_code = 1;

sub usage {
    my ($usage_return_code) = @_;
    $return_code = $usage_return_code;
    eval { use Pod::Usage; pod2usage($return_code); };
    if ($@) {
        die "cannot display help, install perl(Pod::Usage)\n";
    }
}

sub _get_version_string {
    my $dirname     = dirname(__FILE__);
    my $thisversion = qx{git -C $dirname rev-parse HEAD};
    chomp $thisversion;
    die 'Could not parse version' unless $thisversion;
    return "Current version is $thisversion [interface v$OpenQA::Isotovideo::Interface::version]";
}

sub version {
    print _get_version_string() . "\n";
    exit 0;
}

GetOptions(\%options, 'debug|d', 'help|h|?', 'version|v') or usage(1);
usage(0)  if $options{help};
version() if $options{version};

diag(_get_version_string());

# enable debug default when started from a tty
$bmwqemu::direct_output = $options{debug};

STDERR->autoflush(1);
STDOUT->autoflush(1);

$bmwqemu::scriptdir = $installprefix;
bmwqemu::init();
for my $arg (@ARGV) {
    if ($arg =~ /^([[:alnum:]_\[\]\.]+)=(.+)/) {
        my $key = uc $1;
        $bmwqemu::vars{$key} = $2;
        diag("Setting forced test parameter $key -> $2");
    }
}

my $loop = 1;


sub signalhandler {
    my ($sig) = @_;
    bmwqemu::serialize_state(component => 'isotovideo', msg => "isotovideo received signal $sig", log => 1);
    return $loop = 0 if $loop;
    OpenQA::Isotovideo::shutdown("received signal $sig");
    _exit(1);
}

$SIG{TERM} = \&signalhandler;
$SIG{INT}  = \&signalhandler;
$SIG{HUP}  = \&signalhandler;

# make sure all commands coming from the backend will not be in the
# developers's locale - but a defined english one. This is SUSE's
# default locale
$ENV{LC_ALL} = 'en_US.UTF-8';
$ENV{LANG}   = 'en_US.UTF-8';

$return_code = main();

sub main {
    my $cmd_srv_fd;

    checkout_git_repo_and_branch('CASEDIR');

    # Try to load the main.pm from one of the following in this order:
    #  - product dir
    #  - casedir
    #
    # This allows further structuring the test distribution collections with
    # multiple distributions or flavors in one repository.
    $bmwqemu::vars{PRODUCTDIR} ||= $bmwqemu::vars{CASEDIR};

    # checkout Git repo NEEDLES_DIR refers to (if it is a URL) and re-assign NEEDLES_DIR to contain the checkout path
    checkout_git_repo_and_branch('NEEDLES_DIR');

    bmwqemu::ensure_valid_vars();

    # as we are about to load the test modules checkout the specified git refspec,
    # if specified, or simply store the git hash that has been used. If it is not a
    # git repo fail silently, i.e. store an empty variable

    $bmwqemu::vars{TEST_GIT_HASH} = checkout_git_refspec($bmwqemu::vars{CASEDIR} => 'TEST_GIT_REFSPEC');

    # set a default distribution if the tests don't have one
    $testapi::distri = distribution->new;

    load_test_schedule;

    # start the command fork before we get into the backend, the command child
    # is not supposed to talk to the backend directly
    ($cmd_srv_process, $cmd_srv_fd) = commands::start_server($cmd_srv_port = $bmwqemu::vars{QEMUPORT} + 1);

    testapi::init();
    needle::init();
    bmwqemu::save_vars();

    ($testprocess, $testfd) = autotest::start_process();

    OpenQA::Isotovideo::init_backend();

    open(my $fd, ">", "os-autoinst.pid");
    print $fd "$$\n";
    close $fd;

    if (!$bmwqemu::backend->_send_json({cmd => 'alive'})) {
        # might throw an exception
        $bmwqemu::backend->start_vm();
    }

    # launch debugging tools
    my %debugging_tools;
    $debugging_tools{vncviewer}   = ['vncviewer', '-viewonly', '-shared', "localhost:$bmwqemu::vars{VNC}"] if $ENV{RUN_VNCVIEWER};
    $debugging_tools{debugviewer} = ["$bmwqemu::scriptdir/debugviewer/debugviewer", 'qemuscreenshot/last.png'] if $ENV{RUN_DEBUGVIEWER};
    for my $tool (keys %debugging_tools) {
        next if fork() != 0;
        no autodie 'exec';
        { exec(@{$debugging_tools{$tool}}) };
        exit -1;    # don't continue in any case (exec returns if it fails to spawn the process printing an error message on its own)
    }

    $backend_process = $bmwqemu::backend->{backend_process};
    my $io_select = IO::Select->new();
    $io_select->add($testfd);
    $io_select->add($cmd_srv_fd);
    $io_select->add($backend_process->channel_out);

    # stop main loop as soon as one of the child processes terminates
    my $stop_loop = sub { $loop = 0 if $loop; };
    $testprocess->once(collected => $stop_loop);
    $backend_process->once(collected => $stop_loop);
    $cmd_srv_process->once(collected => $stop_loop);

    # now we have everything, give the tests a go
    $testfd->write("GO\n");

    $command_handler = OpenQA::Isotovideo::CommandHandler->new(
        cmd_srv_fd => $cmd_srv_fd,
        backend_fd => $backend_process->channel_in,
    );
    $command_handler->on(tests_done => sub {
            CORE::close($testfd);
            $testfd = undef;
            OpenQA::Isotovideo::stop_autotest;
            $loop = 0;
    });

    my $return_code = 0;

    # enter the main loop: process messages from autotest, command server and backend
    while ($loop) {
        my ($ready_for_read, $ready_for_write, $exceptions) = IO::Select::select($io_select, undef, $io_select, $command_handler->timeout);
        for my $readable (@$ready_for_read) {
            my $rsp = myjsonrpc::read_json($readable);
            if (!defined $rsp) {
                diag sprintf("THERE IS NOTHING TO READ %d %d %d", fileno($readable), fileno($testfd), fileno($cmd_srv_fd));
                $readable = 1;
                $loop     = 0;
                last;
            }
            if ($readable == $backend_process->channel_out) {
                $command_handler->send_to_backend_requester({ret => $rsp->{rsp}});
                next;
            }
            $command_handler->process_command($readable, $rsp);
        }
        if (defined($command_handler->tags)) {
            OpenQA::Isotovideo::check_asserted_screen($command_handler->no_wait);
        }
    }

    # tell the command server that it should no longer process isotovideo commands since we've
    # just left the loop which would handle such commands (otherwise the command server would just
    # hang on the next isotovideo command)
    $command_handler->stop_command_processing;

    # terminate/kill the command server and let it inform its websocket clients before
    OpenQA::Isotovideo::stop_commands('test execution ended');

    if ($testfd) {
        $return_code = 1;    # unusual shutdown
        CORE::close $testfd;
        OpenQA::Isotovideo::stop_autotest();
    }

    diag 'isotovideo ' . ($return_code ? 'failed' : 'done');

    my $clean_shutdown;
    if (!$return_code) {
        eval {
            $clean_shutdown = $bmwqemu::backend->_send_json({cmd => 'is_shutdown'});
            diag('backend shutdown state: ' . ($clean_shutdown // '?'));
        };

        # don't rely on the backend in a sane state if we failed - just stop it later
        eval { bmwqemu::stop_vm(); };
        if ($@) {
            bmwqemu::serialize_state(component => 'backend', msg => "unable to stop VM: $@", log => 1);
            $return_code = 1;
        }
    }

    # read calculated variables from backend and tests
    bmwqemu::load_vars();

    $return_code = handle_generated_assets($command_handler, $clean_shutdown) unless $return_code;
    return $return_code;
}

# clear any previously recorded die message; it was not fatal after all if the execution came this far
$fatal_error = undef;

END {
    OpenQA::Isotovideo::shutdown('test execution ended through exception');

    # in case of early exit, e.g. help display
    $return_code //= 0;

    bmwqemu::serialize_state(component => 'isotovideo', msg => $fatal_error) if $fatal_error;
    print "$$: EXIT $return_code\n";
    $? = $return_code;
}
